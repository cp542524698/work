### tree
#### 基本概念

- 空树（empty tree）
- 非空树：
	- 子节点 children
	- 父节点 parent
	- 根节点 root（没有父节点）
	- 叶子节点 leaf（没有子节点）
	- 兄弟节点sibling（同父节点）
	- 子树subtree（子节点以及子节点的后代）

- 树的高度（height）、深度（depth）
	- 高度：从结点x向下到某个叶结点最长简单路径中边的条数
	- 深度：从根节点【1】往下数，

- 度：节点拥有的子树个数。
- 其中叶子节点的度为0；
- 树的度：内部结点度的最大值。

#### 二叉树
	二叉树(binary)是一种特殊的树，它是每个节点最多有两个子树的树结构，通常子树被称作是 "左子树" 和 "右子树"，二叉树常用于实现二叉搜索树和二叉堆。

	常见的二叉树：
	- 完全二叉树
	- 满二叉树
	- 二叉搜索树
	- 二叉堆
	- AVL树
	- 红黑树
	- 哈夫曼树

#### 完全二叉树（complete binary tree）

	- 定义：设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边
	- 特征：
		- 除 level h外，其他level节点数都达到了最大值；
		- 第h层所有节点都连续集中在最左边；

	- 用途：
		- 效率很高的数据结构
		- 堆是一种完全二叉树或者近似完全二叉树，所以效率极高；

#### 满二叉树（full binary tree）

	- 定义：
		除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树
	- note：
		满二叉树一定是完全二叉树，反之不然；

	- 特征：
		- 高度为h的满二叉树节点个数为：
		1 + 2 + 4 + ... + 2^h = 2^(h+1) - 1 (等比数列求和)
		- 满二叉树的节点个数一定为奇数；

#### 二叉搜索树（binary search tree）

	- 定义：
	二叉搜索树是一种特殊的二叉树，二叉排序树，二叉查找树；
	- 性质：
		- 每个节点最多有两个子树，通常称为左子树和右子树
		- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值
		- 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
		- 它的左右树是一颗二叉搜索树；
	
二叉树的性质：

	1、在非空二叉树的i层上，至多得到有2^i个节点
	2、高度为k的二叉树中，最多有2^(k+1) -1 个节点
	3、在任意一棵二叉树中，若总结点的个数为n0，度为2的结点数为n2，则n0=n2+1
	证明：
		设该二叉树总结点数为n，边为b（这里需要边做中间转换）
		n = n0 + n1 + n2
		n = b + 1(每个节点都由一个边进入，需要除root节点)
		b = n1 + 2n2 (度为1的节点有一条边，度为2的节点有2条边)

		b + 1 = n0 + n1 + n2
		n1 + 2n2 + 1 = n0 + n1 + n2
		n2 + 1 = n0
	
	满完全二叉树性质：
		1、具有n个节点的完全二叉树的高度k为log2（n）；
		2、对于具有n个节点的完全二叉树，如果按照从上（根结点）到下（叶结点）合从左到右的顺序对二叉树中的所有节点从0开始到n-1进行编号，则对于任意的下标为i的节点，有：
		- 如果i=0，则它是根节点，他没有父节点，如果i>0，则它的父节点的下标为（i-1）/2;
		- 如果2i+1<=n-1，则下标为i的节点的左子节点的下标为2i+1；否则下标为i的节点没有左子节点；
		-  如果2i+2<=n-1,则下标为i的节点的右子节点的下标为2i+2;否则，下标为i的节点没有右子节点。

	满二叉树性质：
		- 在满二叉树中，叶结点的个数比分支结点的个数多1；（由性质3可得）

	扩充二叉树性质：
		- 在扩充二叉树中，外部节点的个数比内部节点的个数多1；（由性质6推出）
		- 在任意的扩充二叉树，外部路径长度E和内部路径长度I之间满足一下关系：E=I+2n，其中n为内部节点的个数

二叉树的前、中、后序遍历；

	算法：约瑟夫问题；（2种方法）

	栈与队列
	last in first out
	first in first out

	stl中栈的函数：
	为什么不把读取栈顶元素和弹出栈顶元素方法合并呢？
	- top函数：读取栈顶元素，将结果返回给用户
	- pop函数：将栈顶元素弹出，并不返回结果；
		只有true，false
	为什么上面两个操作不合并呢？？

栈的应用：
	1、深度优先的搜索
	2、表达式求值 //前缀，中缀，后缀表达式
	3、子程序/函数调用的管理
	4、消除递归；

队列：

template <class T> class Queue{
public:
	void clear();
	bool enQueue(const T item);
	bool deQueue(T& item);

	bool getFront(T& item);
	bool isEmpty()
	bool isFull();
}

思考：
	1、顺序队列中只有front， rear两个变量；
长度为mSize=n队列，推导出可以容纳最大元素个数是多少
	2、如果不愿意浪费队列的存储单元，还可以采用什么方法呢；

队列的应用：
	1、消息缓存器
	2、数据cache等
	3、操作系统的资格管理（进程管理，其实是管理优先级队列）
	4、宽度优先搜索

思考：
	1、链式队列往往用单链为什么不用双链
	2、采用虚指方法实现队尾指针（rear，——
	而不是采用实指相比后移一位的，实现的异同，哪种更好；

农夫狼菜羊问题，一家五口过桥问题；

https://www.bilibili.com/video/av10047165/?p=25

完全二叉树使用线性存储（使用数组，如何实现）


二叉搜索树Binary Search Tree（BST）：
	- 空树
	- 非空树：
		+ 对于任意个节点，设其值为k；
		+ 其左子树的节点 < k;
		+ 其右子树的节点 > k;
	- 对树进行中序遍历即可获得有序序列
优点：
	BST不是为了排序，而是为了提高"查找"和"插入删除"关键字的速度；

树的增加，删除
1、如何防止bst退化成线性结构？
2、如何处理BST中的重复关键码？

动态索引：
B树（平衡多分数即非二叉树 balance tree）
m阶B tree满足以下条件：
	- 每个节点最多有m个子节点[m>=2 由阶的定义而来的 ]；
	- 除root和leaf节点外，其他每个节点至少有m/2（m/2取上整）个子节点
		+ 结合第一条可知，每个节点的子节点个数为( [m/2] <= k <= m)
	- root至少有两个子节点 【例外是：B tree只有一个root节点的情况】
	- leaf节点在同一层
	- 非叶子节点如果有k个孩子，则有k-1个关键字。
 	

2-3树：
	-

文件系统是对一个存储设备上的数据和元数据进行组织的机制
双向链表
hash链表
单向链表
红黑树
radix树

1、静态索引
rotate left
rotate right

AVL树 【自平衡二叉排序树】， 特殊的二叉排序树


